// To test some of build.rs' code correctness run:
// cargo build --features=test_build_rs_of_ncurses_rs
// when doing that, the following cfg_attr ensures there are no warnings about unused stuff.
#![cfg_attr(
    all(
        feature = "test_build_rs_of_ncurses_rs",
        not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
    ),
    allow(dead_code)
)]
#![allow(clippy::uninlined_format_args)] // or is it more readable inlined?

extern crate cc;
extern crate pkg_config;

use pkg_config::Library;
use std::env;
use std::ffi::OsStr;
use std::ffi::OsString;
use std::fmt::Write as required_for_writeln_macro;
use std::fs::File;
use std::io::Write as required_for_write_all_function; //in File
use std::os::unix::ffi::OsStrExt;
use std::os::unix::ffi::OsStringExt;
use std::path::Path;
use std::process::Command;
use std::process::ExitStatus;

//Decide whether or not to delete .c and bin files generated by build.rs once they're not needed.
//Defaulting to 'false' because it's a job for 'cargo clean' and
//it might help with debugging build issues if we keep them around.
//even if this were true, we're already keeping 'libwrap.a', so FIXME: if this is set true.
const DELETE_GENERATEDS: bool = false;

// Optional environment variables:

// The below doc comment doesn't apply for these 2 env.vars:
const ENV_VAR_NAME_FOR_LIB: &str = "NCURSES_RS_RUSTC_LINK_LIB";
const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";

/// Assuming we want env.var "NCURSES_RS_CFLAGS" here,
/// and target==host and is "x86_64-unknown-linux-gnu"
/// then calls to Build::try_flags_from_environment() below in code,
/// will try the following env.vars in this order:
/// 1. "NCURSES_RS_CFLAGS_x86_64-unknown-linux-gnu" (notice dashes)
/// 2. "NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu" (notice underscores)
/// 3. "HOST_NCURSES_RS_CFLAGS" or "TARGET_NCURSES_RS_CFLAGS" (if target!=host)
/// 4. "NCURSES_RS_CFLAGS" (our original wanted)
/// and the first one that exists is used instead.
/// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
/// All of the _tried_ ones are emitted as: cargo:rerun-if-env-changed=
/// which means, if NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu is set then NCURSES_RS_CFLAGS won't
/// be emitted which makes sense as this one overrides the rest anyway.
const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";

const IS_WIDE: bool = cfg!(feature = "wide");
const IS_MACOS: bool = cfg!(target_os = "macos");
// Why also not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
const IS_WIDE_AND_NOT_ON_MACOS: bool = IS_WIDE && !IS_MACOS;

// Will search for these lib names and if not found via pkg-config
// then use the fallback name and still try linking with it
// because in most cases it will work anyway.
const NCURSES_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "ncursesw"
} else {
    "ncurses"
};
const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["ncursesw5", NCURSES_LIB_NAME_FALLBACK]
} else {
    &["ncurses5", NCURSES_LIB_NAME_FALLBACK]
};

const MENU_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "menuw"
} else {
    "menu"
};
const MENU_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["menuw5", MENU_LIB_NAME_FALLBACK]
} else {
    &["menu5", MENU_LIB_NAME_FALLBACK]
};

const PANEL_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "panelw"
} else {
    "panel"
};
const PANEL_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["panelw5", PANEL_LIB_NAME_FALLBACK]
} else {
    &["panel5", PANEL_LIB_NAME_FALLBACK]
};

const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    //elements order here matters, because:
    //Fedora has ncursesw+tinfo(without w) for wide!
    //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
    //(presumably because tinfo doesn't depend on wideness?)
    //NixOS has only ncursesw(tinfo is presumably inside it) but -ltinfo still works for it(it's a
    //symlink to ncursesw lib)
    //Gentoo has ncursesw+tinfow
    //
    //These are tried in order and first that links is selected:
    &["tinfow5", "tinfow", "tinfo"]
    //doneFIXME: here ^, user can have in env. this TINFOW_NO_PKG_CONFIG=1 (but not also TINFO_NO_PKG_CONFIG=1) which would cause seg fault on Gentoo because tinfo will be found&linked(instead of tinfow) with one or more of menuw,panelw,ncursesw eg. when doing example ex_5 (ie. menuw,ncursesw,tinfo(no w)); but on Fedora this ncursesw+tinfo(no w) makes sense(because tinfo(no w) has both inside it, somehow, i guess), so we can't really guard against this (well maybe with target_os but what if they change in the future...) instead maybe print a warning if w and non-w are mixed(but only for tinfo is needed), even though it will be a false warning on Fedora, well maybe it won't be if we also check if env. var is set TINFOW_NO_PKG_CONFIG.
} else {
    //no reason to ever fallback to tinfow here when not-wide!
    //Fedora/Gentoo has ncurses+tinfo
    //NixOS has only ncursesw(but works for non-wide), -ltinfo symlinks to ncursesw .so file)
    //so 'tinfo' is safe fallback here.
    &["tinfo5", "tinfo"]
};
//TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
//was v5 newer than the next in list? is it so on other systems?
//like: was it ever ncurses5 newer than ncurses ?
//Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
//might be v6
//This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409

/// finds and emits cargo:rustc-link-lib=
fn find_library(names: &[&str]) -> Option<Library> {
    for name in names {
        //cargo_warn!("Trying lib '{}'",name);
        if let Ok(lib) = pkg_config::probe_library(name) {
            //cargo_warn!("Found lib '{}' '{:?}'",name, lib);
            return Some(lib);
        }
    }
    None
}

/// Emits the passed string(s) prefixed by 'cargo:warning=' on stdout,
/// which cargo will transform into a warning.
/// It acts like println!() macro, so you can call it the same way to do formatting!
/// Will replace newlines in the warning message with spaces,
/// otherwise the text after would not have been seen in the warning.
macro_rules! cargo_warn {
    ($($arg:tt)*) => {
        cargo_warn_unformatted(format!("{}", format_args!($($arg)*)));
    };
}

/// Pass the string to be emitted as a cargo warning.
/// Presumably you've already used format!() on it.
/// Will replace newlines in the warning message with spaces,
/// otherwise the text after would not have been seen in the warning.
fn cargo_warn_unformatted(warn_msg: String) {
    // Replace '\r' with nothing
    // Replace '\n' with space
    let warn_msg = warn_msg.replace('\r', "").replace('\n', " ");
    println!("cargo:warning={}", warn_msg);
}
// -----------------------------------------------------------------
// This is the normal build.rs main(),
// it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
#[cfg(any(
    not(feature = "test_build_rs_of_ncurses_rs"),
    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
))]
fn main() {
    watch_env_var("PKG_CONFIG_PATH");

    let ncurses_lib = find_library(NCURSES_LIB_NAMES);

    //TODO: dedup, unmessify
    //TODO: dedup warning msgs and see when to still emit them.
    if cfg!(feature = "menu") {
        if find_library(MENU_LIB_NAMES).is_none() {
            let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
            //FIXME: on openbsd(at least), the 'menu' linking fails because it depends on ncurses
            //also being linked in, so we must always link with ncurses lib on try_link() which
            //also means we must know if we have to use ncurses lib override before even trying
            //menu,panel,tinfo, and thus pass the ncurses lib name to try_link as third arg.
            if try_link(fallback_lib_name, &ncurses_lib) {
                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
            } else {
                //TODO: find out why this works on openbsd, maybe missing -L paths to the lib which
                //cargo somehow has and uses, despite pkg-config saying it has none.
                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this(and yet it works fine on, at least, OpenBSD). You might need installed ncurses and pkg-config/pkgconf to fix this.", "menu", fallback_lib_name);
            }
            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
            //like it doesn't include some link searchdir paths that are somehow included
            //otherwise. Or, it fails to link because libmenu fails to link without libncurses also
            //being linked!(happens on openbsd, fixing by always linking with libncurses via try_link())
            println!("cargo:rustc-link-lib={}", fallback_lib_name);
        }
    }

    if cfg!(feature = "panel") {
        if find_library(PANEL_LIB_NAMES).is_none() {
            let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
            if try_link(fallback_lib_name, &ncurses_lib) {
                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
            } else {
                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", "panel", fallback_lib_name);
            }
            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
            //like it doesn't include some link searchdir paths that are somehow included
            //otherwise.
            println!("cargo:rustc-link-lib={}", fallback_lib_name);
        }
    }

    //This comment block is about libtinfo.
    //If pkg-config can't find it, use fallback: 'tinfo' or 'tinfow'
    //if cargo can't find it it will ignore it gracefully - NO IT WON'T!
    //if it can find it, it will link it.
    //It's needed for ex_5 to can link  when pkg-config is missing,
    //otherwise you get this: undefined reference to symbol 'noraw'
    //Thus w/o this block, the following command would be needed to run ex_5
    //$ NCURSES_RS_RUSTC_FLAGS="-ltinfo" cargo run --features=menu --example ex_5
    //To emulate this even if you have pkg-config you can tell it to not do its job
    // by setting these env. vars before the above command:
    // $ NCURSES_NO_PKG_CONFIG=1 NCURSESW_NO_PKG_CONFIG=1 NCURSES5_NO_PKG_CONFIG=1 NCURSESW5_NO_PKG_CONFIG=1 the_rest_of_the_command_here
    // Fedora and Gentoo are two that have both ncurses(w) and tinfo(w), ie. split,
    // however Gentoo has ncurses+tinfo and ncursesw+tinfow,
    // but Fedora has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
    // NixOS has only ncursesw (tinfo is presumably inside?) but -lncurses -lncursesw -ltinfo work!
    // but -ltinfow doesn't work! on NixOS and Fedora!
    // On Gentoo -ltinfow works too!
    // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
    // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
    // works!
    let tinfo_name = if let Some(found) = find_library(TINFO_LIB_NAMES) {
        let libs = found.libs;
        assert_eq!(
            libs.len(),
            1,
            "Unexpected pkg-config query for tinfo lib returned more than one lib: '{:?}'",
            libs
        );
        libs.first()
            .unwrap_or_else(|| {
                panic!(
                    "Unexpected panic on trying to get the first found tinfo lib string from: '{:?}'.",
                    libs
                )
            })
            .clone()
    } else {
        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib and tinfo/ncurses all symlink to that same ncursesw.so, except tinfow which doesn't exist but pkg-config points it to -lncursesw), so no need to warn that we didn't find any tinfo.
        //Pick the tinfo lib to link with, as fallback,
        //the first one that links successfully!
        //The order in the list matters!
        TINFO_LIB_NAMES
            .iter()
            .find(|&each| {
                let ret: bool = try_link(each, &ncurses_lib);
                if ret {
                    cargo_warn!("Using lib fallback '{}' which links successfully.", each);
                    println!("cargo:rustc-link-lib={}", each);
                }
                ret
            })
            .unwrap_or_else(|| &"")
            .to_string()
    };
    if IS_WIDE_AND_NOT_ON_MACOS
        && tinfo_name == "tinfo"
        && std::env::var("TINFOW_NO_PKG_CONFIG").is_ok()
    {
        cargo_warn!("Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
    }
    //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
    //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.

    // Gets the name of ncurses lib found by pkg-config, if it found any!
    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
    // and emits cargo:rustc-link-lib= for it unless already done.
    let lib_name = get_ncurses_lib_name(&ncurses_lib);

    watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
        println!("cargo:rustc-flags={}", x);
    }

    check_chtype_size(&ncurses_lib);

    //The code in src/genconstants.c uses initscr() of ncurses (see: $ man 3x initscr)
    //which depends on TERM env.var and will fail if TERM is wrong, say 'TERM=foo',
    //with: "Error opening terminal: foo." and exit code 1
    //therefore rebuild if TERM is changed without needing a 'cargo clean' first:
    watch_env_var("TERM");
    gen_rs(
        "src/genconstants.c",
        "genconstants",
        "raw_constants.rs",
        &ncurses_lib,
        &lib_name,
    );

    gen_rs(
        "src/menu/genconstants.c",
        "genmenuconstants",
        "menu_constants.rs",
        &ncurses_lib,
        &lib_name,
    );

    build_wrap(&ncurses_lib);
}
// -----------------------------------------------------------------

//TODO: look into how to make doc tests and if they'd work with build.rs
/// Creates file with the specified contents.
/// Any existing file with that name is lost.
/// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
fn overwrite_file_contents(file_name: &str, contents: &[u8]) {
    //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
    assert!(
        file_name.starts_with(&get_out_dir()),
        "The file name you wanted to create '{}' should be created in OUT_DIR only",
        file_name
    );
    //FIXME: Maybe don't require utf-8 valid paths? by requiring &str here,
    //the caller would do PathBuf::display() which replaces '\xFF' with the placeholder char
    //which is the replacement character \u{FFFD}
    //Many other programs break at compile time if path contains non-utf8 chars, before we even get here!
    let mut file = File::create(file_name)
        .unwrap_or_else(|err| panic!("Couldn't create file '{}', reason: '{}'", file_name, err));

    file.write_all(contents).unwrap_or_else(|err| {
        panic!(
            "Couldn't write contents to file '{}', reason: '{}'",
            file_name, err
        )
    });
    drop(file); //explicit file close, not needed since it's in a function now!
}

fn get_out_dir() -> &'static str {
    use std::sync::OnceLock;
    static LOCK: OnceLock<String> = OnceLock::new();

    //OUT_DIR is set by cargo during build
    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
    LOCK.get_or_init(|| {
        env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
            panic!(
                "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
                ENV_NAME_OF_OUT_DIR, err
            )
        })
    })
    //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
}

/// Tries to see if linker can find/link with the named library, to create a binary.
/// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
/// This is mainly used when pkg-config is missing.
/// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
/// Returns true if linking succeeded, false otherwise.
fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
    let out_dir = get_out_dir();

    //We won't execute it though, so doesn't matter if it's .exe for Windows
    let out_bin_fname = format!("try_link_with_{}", lib_name);

    //we'll generate this .c file with our contents
    let out_src_full = Path::new(&out_dir)
        .join(format!("{}.c", out_bin_fname))
        .display()
        .to_string();

    let source_code = b"int main(void) { return 0; }";
    overwrite_file_contents(&out_src_full, source_code);
    //TODO: remove commented out code everywhere in build.rs

    let build = cc::Build::new();
    let mut linker_searchdir_args: Vec<String> = Vec::new();
    //Add linker paths from ncurses lib, if any found! ie. -L
    //(this likely will be empty if pkg-config doesn't exist)
    //Include paths(for headers) don't matter! ie. -I
    if let Some(lib) = ncurses_lib {
        for link_path in &lib.link_paths {
            linker_searchdir_args.push("-L".to_string());
            linker_searchdir_args.push(link_path.display().to_string());
        }
    }

    let mut command = get_the_compiler_command_from_build(build);

    let out_bin_full = Path::new(&out_dir)
        .join(out_bin_fname)
        .display()
        .to_string();
    //Create a bin(not a lib) from a .c file
    //though it wouldn't matter here if it's bin or lib, I'm
    //not sure how to find its exact output name after, to delete it.
    //Adding the relevant args for the libs that we depend upon such as ncurses
    command
        .arg("-o")
        .arg_checked(&out_bin_full)
        .arg_checked(&out_src_full)
        .args_checked(["-l", lib_name])
        .args_checked(linker_searchdir_args);
    let exit_status = command.status_or_panic(); //runs compiler
    let ret: bool = exit_status.success();

    if DELETE_GENERATEDS {
        if ret {
            //delete temporary bin that we successfully generated
            std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
                panic!(
                    "Cannot delete generated bin file '{}', reason: '{}'",
                    out_bin_full, err
                )
            });
        }
        //delete the .c that we generated
        std::fs::remove_file(&out_src_full).unwrap_or_else(|err| {
            panic!(
                "Cannot delete generated C file '{}', reason: '{}'",
                out_src_full, err
            )
        });
    }
    return ret;
}

//TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
//make it HashMap with a counter.
/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
/// only once for each ENV_VAR
/// regardless of how many times it gets called.
fn watch_env_var(env_var: &'static str) {
    assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
    use std::collections::HashSet;
    use std::sync::OnceLock;
    use std::sync::{Arc, RwLock};
    // static gets inited only once before main() and is scoped only to this function
    static SHARED_DATA: OnceLock<Arc<RwLock<HashSet<&'static str>>>> = OnceLock::new();
    //the inner value (hashset) is inited only once on first call of this function
    let hs = SHARED_DATA.get_or_init(|| Arc::new(RwLock::new(HashSet::new())));
    // Acquire a write lock to atomically check and insert if necessary
    if let Ok(mut guard) = hs.write() {
        // Critical section where the lock is held
        if !guard.contains(env_var) {
            println!("cargo:rerun-if-env-changed={}", env_var);
            guard.insert(env_var);
        }
    } //lock released here

    //TODO: can use HashMap(since HashSet I hear is just a HashMap underneath) and keep a counter as val
    //this way we'd know how many times an env.var. tried to be emitted, but for what reason we'd
    //wanna know though...
}

/// set some sensible defaults
fn new_build(lib: &Option<Library>) -> cc::Build {
    //XXX: Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
    let mut build = cc::Build::new();
    if let Some(lib) = lib {
        //header file paths eg. for ncurses.h
        build.includes(&lib.include_paths);
        //for path in lib.include_paths.iter() {
        //    build.include(path);
        //}
    }
    build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)

    //XXX:Don't have to emit cargo:rerun-if-env-changed= here because try_flags_from_environment()
    //below does it for us, however it does it on every call! (unless Build::emit_rerun_if_env_changed(false))
    //but if an overriding variant of it is defined like NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu
    //then this weaker one won't be emitted because the override will be the only one in effect.
    //We could forcefully emit anyway, but no point, it will be ignored and just rebuild for no reason.
    //watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);

    //See comment above the const var def. to understand which env.vars are tried here:
    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);

    //these two are already in from the default Build
    //build.flag_if_supported("-Wall");
    //build.flag_if_supported("-Wextra");
    build.flag_if_supported("-Wpedantic");
    //build.flag_if_supported("-Wstrict-prototypes");//maybe fix me: triggers warnings in wrap.c
    build.flag_if_supported("-Weverything"); //only clang

    return build; // explicit return makes it more obvious that the ";" is missing so it's a return!
}

fn build_wrap(ncurses_lib: &Option<Library>) {
    // build.file(source_file), below, doesn't emit this:
    println!("cargo:rerun-if-changed=src/wrap.c");
    let mut build = new_build(ncurses_lib);

    // The following creates `libwrap.a` on linux, a static lib
    build.file("src/wrap.c").compile("wrap");
    //the resulting lib will be kept until deleted by 'cargo clean'
}

fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Command {
    //'cc::Build' can do only lib outputs but we want a binary
    //so we get the command (and args) thus far set and add our own args.
    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
    //(though at least the setting for build.file(source_c_file) won't be,
    // but we don't use that way and instead set it later as an arg to compiler)
    let compiler = build
        .try_get_compiler()
        .expect("Failed Build::try_get_compiler");
    let command = compiler.to_command();
    return command;
}

/// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
/// Uses ncurses include paths and links with ncurses lib(s)
// Note: won't link with tinfo unless pkg-config returned it.
// ie. if `pkg-config ncurses --libs` shows: -lncurses -ltinfo
// So even though we used a fallback tinfo in main, for cargo, it won't be used here. FIXME: if tinfo is needed here ever! (it's currently not, btw)
fn gen_rs(
    source_c_file: &str,
    out_bin_fname: &str,
    gen_rust_file: &str,
    ncurses_lib: &Option<Library>,
    lib_name: &str,
) {
    //TODO: see if build.file() already emits this!
    println!("cargo:rerun-if-changed={}", source_c_file);
    let out_dir = get_out_dir();
    #[cfg(windows)]
    let out_bin_fname = format!("{}.exe", out_bin_fname); //shadowed
    let bin_full = Path::new(&out_dir)
        .join(out_bin_fname)
        .display()
        .to_string();

    let build = new_build(ncurses_lib);
    let mut linker_searchdir_args: Vec<String> = Vec::new();
    if let Some(lib) = ncurses_lib {
        for link_path in &lib.link_paths {
            linker_searchdir_args.push("-L".to_string());
            linker_searchdir_args.push(link_path.display().to_string());
        }
    }

    let mut command = get_the_compiler_command_from_build(build);

    //create a bin(not a lib) from a .c file
    //adding the relevant args for the libs that we depend upon such as ncurses
    command
        .arg("-o")
        .arg_checked(&bin_full)
        .arg_checked(source_c_file)
        .args_checked(["-l", lib_name])
        .args_checked(linker_searchdir_args);
    command.success_or_panic(); //runs compiler

    //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
    //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
    //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
    //code 1 because env.var. TERM=a_terminal_not_in_term_database
    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic();

    //Write the output from executing the binary into a new rust source file .rs
    //That .rs file is later used outside of this build.rs, in the normal build
    let gen_rust_file_full_path = Path::new(&out_dir)
        .join(gen_rust_file)
        .display()
        .to_string();
    overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
    //we ignore stderr.
    //we don't delete this file because it's used to compile the rest of the crate.
}

fn check_chtype_size(ncurses_lib: &Option<Library>) {
    let out_dir = get_out_dir();
    let src_full = Path::new(&out_dir)
        .join("chtype_size.c")
        .display()
        .to_string();
    let bin_name = if cfg!(windows) {
        "chtype_size.exe"
    } else {
        "chtype_size"
    };
    let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();

    let contents = br#"// autogenerated by build.rs
#include <assert.h>
#include <limits.h>
#include <stdio.h>

#include <ncurses.h>

int main(void)
{
    if (sizeof(chtype)*CHAR_BIT == 64) {
        puts("cargo:rustc-cfg=feature=\"wide_chtype\"");
    } else {
        /* We only support 32-bit and 64-bit chtype. */
        assert(sizeof(chtype)*CHAR_BIT == 32 && "unsupported size for chtype");
    }

#if defined(NCURSES_MOUSE_VERSION) && NCURSES_MOUSE_VERSION == 1
    puts("cargo:rustc-cfg=feature=\"mouse_v1\"");
#endif
    return 0;
}
"#;
    overwrite_file_contents(&src_full, contents);

    let build = new_build(ncurses_lib);

    let mut command = get_the_compiler_command_from_build(build);

    command
        .arg("-o")
        .arg_checked(&bin_full)
        .arg_checked(&src_full);
    command.success_or_panic(); //runs compiler

    let features = Command::new(&bin_full).output_success_or_panic();

    //for cargo to consume
    print!("{}", String::from_utf8_lossy(&features.stdout));

    if DELETE_GENERATEDS {
        std::fs::remove_file(&src_full).unwrap_or_else(|err| {
            panic!(
                "Cannot delete generated C file '{}', reason: '{}'",
                src_full, err
            )
        });
        std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
            panic!(
                "cannot delete compiled bin file '{}', reason: '{}'",
                bin_full, err
            )
        });
    }
}

//call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
    //Was it found(and thus printed) by pkg_config::probe_library() ?
    let mut already_printed: bool = false;
    let lib_name: String;
    watch_env_var(ENV_VAR_NAME_FOR_LIB);
    match std::env::var(ENV_VAR_NAME_FOR_LIB) {
        Ok(value) => lib_name = value,
        Err(_) => {
            if let Some(ref lib) = ncurses_lib {
                // if here, `pkg-config`(shell command) via pkg_config crate,
                // has found the ncurses lib (eg. via the `ncurses.pc` file)
                // You can get something like this ["ncurses", "tinfo"] as the lib.libs vector
                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
                // so find whichever it is and return that:
                let substring_to_find = "curses";
                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
                    //If we're here, the function calls to pkg_config::probe_library()
                    //from above ie. through find_library(), have already printed these:
                    //   cargo:rustc-link-lib=ncurses
                    //   cargo:rustc-link-lib=tinfo
                    //so there's no need to re-print the ncurses line as it would be the same.
                    already_printed = true;
                    lib_name = found.clone();
                } else {
                    // Construct the repeated pkg-config command string
                    let repeated_pkg_config_command: String = NCURSES_LIB_NAMES
                        .iter()
                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
                        .collect::<Vec<_>>()
                        .join("` or `");

                    panic!(
                    "pkg_config(crate) reported that it found the ncurses lib(s) but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`\n
                    Try setting NCURSES_NO_PKG_CONFIG=1 and/or NCURSESW_NO_PKG_CONFIG=1 to disable pkg-config and thus allow for the fallback to lib name 'ncurses' respectively 'ncursesw' to be tried. Or fix ncurses.pc or ncursesw.pc file.",
                    substring_to_find,
                    repeated_pkg_config_command
                    );
                }
            } else {
                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                let what_lib = NCURSES_LIB_NAME_FALLBACK.to_string();
                // On FreeBSD it works without pkgconf and ncurses(6.4) installed but it will fail
                // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
                // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
                // that is, when pkgconf or pkg-config are missing, yet the libs are there.
                // Print the warning message, but use old style warning with one ":" not two "::",
                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
                cargo_warn!("Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
                //fallback lib name: 'ncurses' or 'ncursesw'
                //if this fails later, there's the warning above to get an idea as to why.
                lib_name = what_lib;
            }
        }
    };
    if !already_printed {
        //TODO: try_link() ? then refactor the warning messages.
        println!("cargo:rustc-link-lib={}", lib_name);
    }
    lib_name
}

//trait MyOutput {}
//
//impl MyOutput for std::process::Output {}

trait MyExitStatus {
    fn success_or_panic(self) -> ExitStatus;
}

impl MyExitStatus for std::process::ExitStatus {
    fn success_or_panic(self) -> ExitStatus {
        if self.success() {
            self
        } else {
            let how: String;
            if let Some(code) = self.code() {
                how = format!(" with exit code {}.", code);
            } else {
                how = ", was it terminated by a signal?!".to_string();
            }
            panic!(
                "!!! Compiler failed{} Is ncurses installed? \
        pkg-config or pkgconf too? \
        it's 'ncurses-devel' on Fedora; \
        run `nix-shell` first, on NixOS. \
        Or maybe it failed for different reasons which are seen in the errored output above.",
                how
            )
        }
    }
}

// Define an extension trait for Command
trait MyCompilerCommand {
    fn output_or_panic(&mut self) -> std::process::Output;
    fn output_success_or_panic(&mut self) -> std::process::Output;
    fn success_or_panic(&mut self) -> ExitStatus;
    //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
    fn just_status_or_panic(&mut self) -> ExitStatus;
    fn status_or_panic(&mut self) -> ExitStatus;
    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
    fn show_what_will_run(&mut self) -> &mut Self;
    fn get_program_or_panic(&self) -> &str;
    fn get_what_will_run(&self) -> (String, usize, String);
    fn assert_no_nul_in_args(&mut self) -> &mut Self;
    /// Panics if arg has \0 in it.
    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
    where
        I: IntoIterator<Item = S>,
        S: AsRef<OsStr>;
    /// Panics if arg has \0 aka NUL in it,
    /// otherwise the original Command::arg would've set it to "<string-with-nul>"
    /// Doesn't do any other checks, passes it to Command::arg()
    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
}

fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
    let os_str = arg.as_ref();
    for &byte in os_str.as_bytes() {
        if byte == 0 {
            return true;
        }
    }
    false
}

/// Args with \0 in them, passed to std::process::Command::arg() or ::args()
/// get replaced(by those calls)entirely with this: "<string-with-nul>"
const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
// Implement the extension trait for Command, so you can use methods on a Command instance even
// though it's a type that's not defined here but in std::process
impl MyCompilerCommand for std::process::Command {
    /// Executes Command::output() and gives you Output struct or panics
    /// but the exit code may not have been 0
    fn output_or_panic(&mut self) -> std::process::Output {
        self.output().unwrap_or_else(|err| {
            self.panic(err, "generated bin"); //TODO: let caller provide this
        })
    }

    /// Executes Command::output() and gives you Output struct or panics
    /// also panics if exit code was not 0 and shows you stdout/stderr if so.
    fn output_success_or_panic(&mut self) -> std::process::Output {
        let output = self.output_or_panic();
        // test this with: `$ TERM=foo cargo build`
        let show_stdout_stderr = || {
            //XXX: presumably eprintln! and std::io::stderr().write_all().unwrap() write to same stderr
            //stream and both would panic if some error would happen when writing to it!
            eprintln!("But here's its stdout&stderr:");
            eprintln!("|||stdout start|||");
            //Preserve stdout/stderr bytes, instead of lossily convert them to utf-8 before showing them.
            //show stdout of executed binary, on stderr
            std::io::stderr().write_all(&output.stdout).unwrap();
            eprintln!("\n|||stdout end||| |||stderr start|||");
            //show stderr of executed binary, on stderr
            std::io::stderr().write_all(&output.stderr).unwrap();
            eprintln!("\n|||stderr end|||");
        };
        let prog = self.get_program_or_panic();
        let and_panic = || -> ! {
            panic!(
                "due to the above-reported error while executing '{}'.",
                //self.get_program_or_panic()
                prog
            );
        };

        let exit_code = output.status.code().unwrap_or_else(|| {
            //we get here if it segfaults(signal 11), so if exited due to signal
            //but unsure if we get here for any other reasons!
            //To test this branch uncomment a segfault line early in src/genconstants.c then `cargo build`

            let basename=Path::new(prog).file_name().unwrap_or_else(|| {
                eprintln!("Couldn't get basename for '{}'", prog);
                OsStr::new("") //refusing to panic over this
            });
            let basename=basename.to_str().unwrap_or_else(|| {
                eprintln!("Couldn't convert OsStr '{:?}' to &str", basename);
                "" //refusing to panic over this
            });
            eprintln!(
                "!!! Execution of '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
                prog, basename
                );
            show_stdout_stderr();
            and_panic();
        });
        if 0 != exit_code {
            eprintln!(
                "!!! Execution of '{}' failed with exit code '{}'",
                prog, exit_code
            );
            show_stdout_stderr();
            eprintln!(
                //FIXME: this msg can't be part of the (future)extension trait impl, it's for src/genconstants.c only.
                "!! Maybe you need to try a different value for the TERM environment variable !!"
            );
            and_panic();
        } else {
            return output;
        }
    }

    /// Executes Command::status().success() and panics if it any fail
    /// This means exit code 0 is ensured.
    /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
    fn success_or_panic(&mut self) -> ExitStatus {
        let exit_status: ExitStatus = self.status_or_panic().success_or_panic();
        exit_status
    }

    //XXX: can't override arg/args because they're not part of a Trait in Command
    //so would've to wrap Command in my own struct for that. This would've ensured
    //that any added args were auto-checked.
    /// panics if any args have \0 aka nul in it, else Command will panic later, on execution.
    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
    where
        I: IntoIterator<Item = S>,
        S: AsRef<OsStr>,
    {
        for arg in args {
            self.arg_checked(arg.as_ref());
        }
        self
    }

    /// panics if arg has \0 aka nul in it, else Command will panic later, on execution.
    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
        if has_null_byte(&arg) {
            //If the arg has NUL ie. \0  in it then arg got replaced already
            //with "<string-with-nul>", internally, by std::process::Command::arg() .
            //The found arg here will be shown with \0 in this Debug way.
            panic!(
                "Found arg '{:?}' that has at least one \\0 aka nul in it! \
                   This would've been replaced with '{}'.",
                arg.as_ref(),
                REPLACEMENT_FOR_ARG_THAT_HAS_NUL
            );
        }
        self.arg(arg)
    }

    /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
    /// which is "<string-with-nul>" then this will panic, it's a false positive.
    fn assert_no_nul_in_args(&mut self) -> &mut Self {
        let args = self.get_args();
        for (count, arg) in args.enumerate() {
            if let Some(fully_utf8_arg) = arg.to_str() {
                //If the arg had NUL ie. \0  in it then arg got replaced already
                //with "<string-with-nul>", internally, by std::process::Command::arg() .
                if fully_utf8_arg == REPLACEMENT_FOR_ARG_THAT_HAS_NUL {
                    panic!(
                        "Found arg number '{}' that has \\0 aka NUL in it! \
                           It got replaced with '{}'.",
                        count + 1,
                        REPLACEMENT_FOR_ARG_THAT_HAS_NUL
                    );
                }
            }
        }
        self
    }

    fn get_program_or_panic(&self) -> &str {
        let program = self.get_program();
        let p_prog = program
            .to_str()
            .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
        //TODO: "Compiler" is too specific here, could be we're running just a bin we created!
        p_prog
    }

    fn get_what_will_run(&self) -> (String, usize, String) {
        let p_prog = self.get_program_or_panic();
        let args = self.get_args();
        let how_many_args: usize = args.len();
        let formatted_args: String = args
            .map(|arg| {
                //If the arg had NUL ie. \0  in it then arg got replaced already
                //with "<string-with-nul>", internally, by std::process::Command::arg()
                //if it was added via Command::arg() or Command::args().
                //To prevent that use Command::arg_checked() and ::args_checked()
                if let Some(fully_utf8_arg) = arg.to_str() {
                    fully_utf8_arg.to_string()
                } else {
                    //None aka not fully utf8 arg
                    //then we show it as ascii + hex
                    let mut broken_arg = String::new();
                    //use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
                    for byte in arg.as_bytes() {
                        match std::char::from_u32(*byte as u32) {
                            Some(c) if c.is_ascii() => broken_arg.push(c),
                            _ => {
                                write!(&mut broken_arg, "\\x{:02X}", byte).expect("Failed to write")
                            }
                        }
                    }
                    broken_arg
                }
            })
            .collect::<Vec<String>>()
            .join("\" \"");
        //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
        //for the generic Vec<String> i think. Then, we won't have to return how_many_args!

        //return this tuple
        (
            p_prog.to_string(),
            how_many_args,
            format!("\"{}\"", formatted_args),
        )
    }

    /// just like Command::status() but panics if it can't execute it,
    /// ie. if status() would've returned an Err
    /// returns ExitStatus whether it be 0 or !=0
    /// Doesn't show you what will be executed and doesn't check args.
    /// (not meant to be used outside)
    fn just_status_or_panic(&mut self) -> ExitStatus {
        // Call the original status() method and handle the potential error
        self.status().unwrap_or_else(|err| {
            self.panic(err, "compilation"); //TODO: let caller provide this?!
        })
    }

    /// Shows command that will execute and checks args, only after this
    /// it's gonna be trying to do .status()
    /// Panics if status would've returned an Err
    fn status_or_panic(&mut self) -> ExitStatus {
        self.show_what_will_run()
            .assert_no_nul_in_args()
            .just_status_or_panic()
    }

    /// Used only for build.rs tests:
    /// this should be exactly like status_or_panic() except it won't check that args
    /// aren't nul-containing and thus won't panic before the original status() gets run, thus
    /// allowing it to panic on nul.
    /// (not meant to be used outside)
    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus {
        self.show_what_will_run().just_status_or_panic()
    }

    /// (not meant to be used outside)
    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
        let (p_prog, how_many_args, formatted_args) = self.get_what_will_run();
        let extra_space = if what_type_of_command.is_empty() {
            ""
        } else {
            " "
        };
        panic!(
            "Failed to run {}{}command '{}' with '{}' args: '{}', reason: '{}'",
            what_type_of_command, extra_space, p_prog, how_many_args, formatted_args, err
        )
    }

    /// shows on stderr, which command will be executed.
    fn show_what_will_run(&mut self) -> &mut Self {
        let (exe_name, how_many_args, formatted_args) = self.get_what_will_run();
        eprintln!(
            "!! Next, attempting to run compilation command '{}' with '{}' args: '{}'",
            exe_name, how_many_args, formatted_args
        );
        self
    }
}

/// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
/// This won't happen if you use --all-features
#[cfg(all(
    feature = "test_build_rs_of_ncurses_rs",
    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
))]
fn main() {
    test_assert_works();
    test_invalid_utf8_in_program();
    test_nul_in_arg_unchecked();
    test_nul_in_arg();
    test_no_panic_in_command();
    test_panic_for_not_found_command();
    test_panic_for_command_non_zero_exit();
    test_get_what_will_run();
    test_assert_no_nul_in_args();

    eprintln!("\n-------------------------------------
              \n!!! All build.rs tests have passed successfully! Ignore the above seemingly erroneous output, it was part of the successful testing !!!\nYou're seeing this because you tried to build with --features=test_build_rs_of_ncurses_rs");

    // This stops the build from continuing which will fail in other places due to build.rs not
    // doing its job, since we've only just tested build.rs not used it to generate stuff.
    std::process::exit(5);
}
//The test functions are left outside of 'test_build_rs_of_ncurses_rs' feature gate
//so that they're tested to still compile ok.

#[allow(dead_code)]
fn test_assert_works() {
    let result = std::panic::catch_unwind(|| {
        #[allow(clippy::assertions_on_constants)]
        {
            assert!(false, "!! just tested if asserts are enabled !!");
        }
    });
    #[allow(clippy::manual_assert)]
    if result.is_ok() {
        panic!("Assertions are disabled in build.rs, should not happen!");
    }
}

#[allow(dead_code)]
fn test_no_panic_in_command() {
    let expected_ec = 42;
    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
    let args_ok = &["-c", "exit 0"];
    let args_fail = &["-c", &format!("exit {}", expected_ec)];
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_ok);
        //execute: sh -c 'exit 0'`
        command.status_or_panic();
    });
    let fail_msg = format!(
        "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
        cmd,
        std::env::var("PATH")
    );
    assert!(result.is_ok(), "{}", fail_msg);

    // executed bin exits with exit code 0, or it would panic ie. fail the test
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_ok);
        //execute: sh -c 'exit 0'`
        command.success_or_panic();
    });
    assert!(result.is_ok(), "{}", fail_msg);

    // executed bin exits with specific exit code 2
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_fail);
        //execute: sh -c 'exit 42'`
        let exit_status = command.status_or_panic();
        assert_eq!(
            exit_status.code().expect("was command killed by a signal?"),
            expected_ec,
            "Command should've exited with exit code '{}'.",
            expected_ec
        );
    });
    assert!(result.is_ok(), "{}", fail_msg);
}

#[allow(dead_code)]
fn test_panic_for_not_found_command() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("some non-exitent command");
        command.args([OsString::from("ar♥g1")]);
        command.status_or_panic();
    });
    let expected_panic_msg=
     "Failed to run compilation command 'some non-exitent command' with '1' args: '\"ar♥g1\"', reason: 'No such file or directory (os error 2)'";
    expect_panic(result, expected_panic_msg);

    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("some non-exitent command");
        command.args([OsString::from("ar♥g1")]);
        command.success_or_panic();
    });
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_panic_for_command_non_zero_exit() {
    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
    let args_fail = &["-c", &format!("exit 43")];
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_fail);
        command.success_or_panic();
    });
    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_invalid_utf8_in_program() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(OsString::from_vec(
            b"test_invalid_utf8_\xFFin_program".to_vec(),
        ));
        command.args([
            OsString::from("ar♥g1"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic();
    });
    expect_panic(
        result,
        "Compiler executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
    );
}

fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
    if result.is_err() {
        if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
            // Uncomment this to can copy/paste it for asserts:
            //println!("!!!!!!!!!! Panic message: {:?}", err);
            assert_eq!(
                err, expected_panic_message,
                "!!! Got different panic message than expected !!!"
            );
        }
    } else {
        panic!(
            "No panic was thrown! But was expecting this panic: '{}'",
            expected_panic_message
        );
    };
}

#[allow(dead_code)]
fn test_nul_in_arg_unchecked() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_arg_unchecked.exe");
        command.args([
            OsString::from("ar♥g1"),
            OsString::from("a\0rg2"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic_but_no_check_args();
    });
    expect_panic(result,
         "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"ar♥g1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"
        );
}

#[allow(dead_code)]
fn test_nul_in_arg() {
    //via .arg()
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_arg.exe");
        command.arg_checked(OsString::from("ar♥g1"));
        command.arg_checked(
            // would panic here
            OsString::from("a\0rg2"),
        );
        command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
        command.status_or_panic();
    });
    let expected_panic_msg=
         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been replaced with '<string-with-nul>'.";
    expect_panic(result, expected_panic_msg);
    //via .args()
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_args.exe");
        command.args_checked([
            // would panic here
            OsString::from("ar♥g1"),
            OsString::from("a\0rg2"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic();
    });
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_get_what_will_run() {
    let expected_prog = "test_get_what_will_run.exe";
    let mut command = Command::new(expected_prog);
    command.arg_checked(OsString::from("ar♥g1"));
    command.args_checked([
        // would panic here
        OsString::from_vec(b"my\xffarg3".to_vec()),
        OsString::from("arg4"),
    ]);
    command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
    let (prog, how_many_args, formatted_args) = command.get_what_will_run();
    let expected_hma = 4;
    let expected_fa = "\"ar♥g1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
    assert_eq!(prog, expected_prog);
    assert_eq!(how_many_args, expected_hma);
    assert_eq!(formatted_args, expected_fa);
}

#[allow(dead_code)]
fn test_assert_no_nul_in_args() {
    let expected_prog = "test_get_what_will_run.exe";
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(expected_prog);
        command.arg("a\0here");
        command.assert_no_nul_in_args();
    });
    expect_panic(
        result,
        r##"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'."##,
    );

    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(expected_prog);
        command.arg("no nul in this arg here");
        command.assert_no_nul_in_args();
    });
    assert!(result.is_ok(), "!!! This should not have panicked !!!");
}
